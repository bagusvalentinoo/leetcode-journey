/**
 * Problem: 928. Minimize Malware Spread II
 *
 * Difficulty: Hard
 *
 * Language: JavaScript
 *
 * Performance: Runtime - 12 ms (Beats 100%)
 */

/**
 * Finds the node to remove for minimal malware spread
 *
 * @param {number[][]} graph - Adjacency matrix
 * @param {number[]} initial - Initially infected nodes
 *
 * @returns {number} - Node to remove
 */
const minMalwareSpread = (graph, initial) => {
  // Number of nodes
  const n = graph.length
  // Array to store the parent of each node
  const father = Array.from({ length: n }, (_, i) => i)
  // Array to store the size of each component
  const size = new Array(n).fill(1)
  // Set of initially infected nodes
  const initialSet = new Set(initial)

  // Helper function to find the root of a node
  const find = (a) => {
    // If the node is not its own parent, find the root
    if (father[a] !== a) father[a] = find(father[a])

    // Return the root
    return father[a]
  }

  // Helper function to union two nodes
  const union = (a, b) => {
    // Find the root of each node a and b
    const fa = find(a)
    const fb = find(b)

    // If the nodes are already in the same component, return
    if (fa === fb) return
    // If the root of a is greater than the root of b, union a with b
    if (size[fa] > size[fb]) {
      father[fb] = fa
      size[fa] += size[fb]
    }
    // If the root of b is greater than the root of a, union b with a
    else {
      father[fa] = fb
      size[fb] += size[fa]
    }
  }

  // Union all nodes that are not initially infected
  for (let i = 0; i < n; i++) {
    // If the node is initially infected, skip
    if (initialSet.has(i)) continue

    // Union all nodes that are not initially infected
    for (let j = i + 1; j < n; j++) {
      // If the node is initially infected, skip
      if (initialSet.has(j)) continue
      // If the nodes are connected, union them
      if (graph[i][j] === 1) union(i, j)
    }
  }

  // Array to store the initial malware of each component
  const infected = new Array(n).fill(-1)

  // For each initially infected node, find all its neighbors
  for (const malware of initial) {
    for (let neighbour = 0; neighbour < n; neighbour++) {
      // If the node is not connected or is initially infected, skip
      if (graph[malware][neighbour] === 0 || initialSet.has(neighbour)) continue

      // Find the root of the neighbor
      const fn = find(neighbour)

      // If the neighbor is not infected, set the initial malware
      if (infected[fn] === -1) infected[fn] = malware
      // If the neighbor is infected by a different malware, set it to -2
      else if (infected[fn] !== malware) infected[fn] = -2
    }
  }

  // Array to store the count of nodes infected by each malware
  const cnt = new Array(n).fill(0)

  /**
   * For each node, find the root and count the number of nodes infected
   * by each malware
   */
  for (let i = 0; i < n; i++) {
    // Find the root of the node
    const fi = find(i)

    // If the node is infected by a malware, count it
    if (infected[fi] > 0) {
      cnt[infected[fi]] += size[fi]
      infected[fi] = -3
    }
  }

  // Find the malware with the maximum count of infected nodes
  let max = initial[0]
  let maxSize = cnt[initial[0]]

  // For each malware, find the maximum count of infected nodes
  for (let i = 1; i < initial.length; i++) {
    // Get the current malware
    const malware = initial[i]

    // If the current malware has more infected nodes, update the maximum
    if (cnt[malware] > maxSize) {
      maxSize = cnt[malware]
      max = malware
    }
    // If the current malware has the same number of infected nodes, choose the smaller malware
    else if (cnt[malware] === maxSize && max > malware) max = malware
  }

  // Return the malware with the maximum count of infected nodes
  return max
}
