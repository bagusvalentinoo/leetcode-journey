/**
 * Problem: 924. Minimize Malware Spread
 *
 * Difficulty: Hard
 *
 * Language: JavaScript
 *
 * Performance: Runtime - 5 ms (Beats 100%)
 */

/**
 * Minimize malware spread by removing one node from the initial infected list
 *
 * @param {number[][]} graph - The network adjacency matrix
 * @param {number[]} initial - The initially infected nodes
 *
 * @returns {number} - The node to remove to minimize spread
 */
const minMalwareSpread = (graph, initial) => {
  // Helper function to perform DFS
  const dfs = (graph, colors, node, color) => {
    colors[node] = color // Mark the current node as visited

    // Perform DFS to find all nodes in the same component
    for (let nei = 0; nei < graph.length; nei++)
      // If the node is not visited and is connected to the current node
      if (graph[node][nei] === 1 && colors[nei] === -1)
        dfs(graph, colors, nei, color)
  }

  // Number of nodes in the graph
  const n = graph.length
  let c = 0

  // Array to store the color of each node
  const colors = new Array(n).fill(-1)

  // Perform DFS to find all nodes in the same component
  for (let node = 0; node < n; node++)
    // If the node is not visited
    if (colors[node] === -1) dfs(graph, colors, node, c++)

  // Array to store the size of each component
  const size = new Array(c).fill(0)

  // Count the size of each component
  for (const color of colors) size[color]++

  // Array to store the count of initial nodes in each component
  const colorCount = new Array(c).fill(0)

  // Count the number of initial nodes in each component
  for (const node of initial) colorCount[colors[node]]++

  // Find the node to remove
  let ans = Number.MAX_VALUE

  // Iterate over the initial nodes
  for (const node of initial) {
    const c = colors[node]
    // If the component has only one initial node
    if (colorCount[c] === 1) {
      // If this is the first initial node or the current component is larger
      if (ans === Number.MAX_VALUE) ans = node
      // If the current component is larger
      else if (size[c] > size[colors[ans]]) ans = node
      // If the current component is the same size as the previous component
      else if (size[c] === size[colors[ans]] && node < ans) ans = node
    }
  }

  // If no initial node was found
  if (ans === Number.MAX_VALUE)
    // Find the smallest initial node
    for (const node of initial) ans = Math.min(ans, node)

  return ans
}
